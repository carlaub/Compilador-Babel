const CTE1 = "F2P2.bab" ;
CONST CTE2 = ((3 - 1) * 4 / 2;  //falta )
var v4:logic ;
const MIN = -50;
const MAX = 50;
CoNsT CTE4 =  AND cert ;   //falta operando
var  v1:sencer ;

VaR v5: vector [MIN . MAX] de sencer;  // . en lugar de ..
VaR v5:vector [MIN .. MAX] dr sencer v5;	// dr en lugar de de
VaR v5: vector [MIN .. MAX] de  ;		// falta tipo

fUNcIO S0): sencer;  // falta (
	var i: senecr;    //sencer mal escrito		
func
	escriure("Starting ", CTE1,);  //sobra ,
	i = min;
	mentre cert fer
		si i = MAX llavors   //= en lugar de ==
		  x=0;
		sino
			v5[i = i + 1;   //falta ]
			i = (j>10)? 2: m+n;
		fisi;	
	fimentre;
fifunc;

funcio S(perval a1: sencer, prval b:sencer ): logic;  //val mal escrito
func
	
	SI b == 0 llavors
		escriure("Bad news!");
		retornar true or X;  
	fiSi;
	sI b == a1 LLAVORS escriure("Wow!, jackpod!"); fisi;
	si (b > 0) AND (b <> a1) LLavors
		escriure("The variable value is ", b);
	fisi;
fifunc;

funcio F(perval val1:secer, perval val2 : sencer, perref ref1 : logic): sencer; //sencer mal escrito
	const N = MAX - 1;
	var i:sencer;
var j:sencer;
func
	ref1 = CeRt ORd Fals;  //ord en lugar de or
	retornar s0();
	cicle
		escriure("Enter a number (-1 exits)",v6 x );  // falta un operador en la segunda expresion
		llegir(val1);
		si val1 <= -1 llavors
			ref1 = FaLs;
			x = (x>1)? x+1:x+2; //falta el si
			y = x or y;
			x = (x>1)? x+1:x+2; //falta el si
			x = si(x>1) x+1:x+2; //falta el ?
				
		
		sino
			eScrIuRe( "You wrote ", val1);
			i = 0;
			percada k en x+  Fer  // la segunda expresion esta mal
				i+ = i / 1;   //parte de izquierda de expresion mal
				j = -1 * i;
			fiPer;
			retornar s(val1, i);
		fisi;
	fins cert;
	si (ref1 == not FAls) OR (ref1 <> CErt) llavors 
		retornar 0; 
	sino
		si esta(j, v5) llavors
			escriure("Bingo!");
		sino
			F = 10;
		fisi;
	fisi;
fifunc;

prog
	v1 := F(v2, v3, v4);  //:= en lugar de =
fiprog
